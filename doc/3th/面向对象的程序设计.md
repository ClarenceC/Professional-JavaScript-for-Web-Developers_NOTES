# 面向对象的程序设计

OO （Object-Oriented） 面向对象,在面向对象的语言里面有一个类的概念，通过类可以创建任意多个具有相同属性的方法和对象。而 ECMAScript 中类的概念是通过继承链去实现的。

简单的一个类的对象就是一个 Object 的实例,里面对一个实体类的抽象有属性和方法：

```javascript
    var person = {  // Person 类的实体
        name: "Nicholas",
        age: 29,
        job: "Software Engineer",
        sayName: function() {
            alert(this.name)
        }
    }
```

ECMA-262 第 5 版中在定义只有内部才用的特性时，描述了属性的各种特征。数据的特性含有4个的行为特性：
- **`Configurable`** 表示表示能否 delete 删除属性重新定义，或者能否修改属性的特性,默认为 `true`。
- **`Enumberable`** 表示是否可枚举的，能否通过 `for-in` 循环返回属性。默认为 `true`。
- **`Writable`** 表示能否修改属性的值。默认为 true。
- **`Value`** 表示这个属性的值，写入或者读出都是读写这个值。 不设置默认为 `undefined`。
- **`Get`** 在读取属性时调用的函数。 默认值为 undefined。
- **`Set`** 在写入属性时调用的函数。 默认值为 undefined。

在 ECMAScript5 中,使用 `Object.definedProperty()` 方法来修改属性的默认特性。在很多架框中也应用这个方法来实现，虚拟 DOM 双向数据绑定。而 `Object.definedProperties()` 方法能同时设置多个属性。

```javascript
    var person = {}
    Object.defineProperty(person, "name", {
        configurable: false, // 设为 false 后就会有很多的限制，不能配置数据属性
        writable: false,
        value: "Nicholas"
    })

    console.log(person.name) // "Nicholas"
    person.name = "Greg"
    console.log(person.name) // "Nicholas" 因为上面设置了不能修改值，所以值没变化
```

```javascript
    var book = {
        _year: 2004,
        edition: 1
    }

    Object.definedProperty(book, "year", {
        get: function() {
            return this._year
        },
        set: function(newValue) {
            if(newValue > 2004) {
                this._year = newValue
                this.edition += newValue - 2004
            }
        }
    })

    book.year = 2005
    console.log(book.edition)
```


`Object.getOwnPropertyDescriptor()` 方法能取得给定属性的描述符，描述特性。

```javascript
    var book = {}
    Object.definedProperties(book, {
        _year: {
            value: 2004
        },
        edition: {
            value: 1
        },
        year: {
            get: function() {
                return this._year
            },
            set: function() {
                if(newValue > 2004) {
                    this._year = newValue
                    this.edition += newValue - 2004
                }
            }
        }
    })

    var descriptor = Object.getOwnPropertyDescriptor(book, "_year")
    console.log(descriptor.value) //2004
    console.log(descriptor.configurable) //false
    console.log(typeof descriptor.get) // undefined

    var descriptor = Object.getOwnPropertyDescriptor(book, "year")
    console.log(descriptor.value)   // undefined
    console.log(descriptor.enumerable) // false
    console.log(typeof descriptor.get) // "function"
```

## 创建对象

除了构造函数和对象字面量创建对象的方式外。还有其它抽象的方式。

### 工厂模式

通过抽象具体对象的类，再通过方法那生成不同数据的实体对象。

1. 工厂函数

```javascript
    function createPerson(name, age, job) {
        var o = new Object()
        o.name = name
        o.age = age
        o.job = job
        o.sayName = function() {
            console.log(this.name)
        }
        return o // 最后返回实体对象
    }
    var person1 = createPerson("Nicholas", 29, "Software Engineer")
    var person2 = createPerson("Greg", 27, "Doctor") // 不同对象
```

2. 构造函数模式

```javascript
    function Person(name, age, job) {
        this.name = name
        this.age = age
        this.job = job
        this.sayName = function() {
            console.log(this.name)
        }
    }
    var person1 = new Person("Nicholas", 29, "Software Engineer")
    var person2 = new Person("Greg", 27, "Doctor") // 不同对象
```

因为把方法写到构造函数里面会每个生成的对象里面包含方法会占用额外的空间，所以一般把函数写到原型链上。

3. 原型模式

```javascript
    
```