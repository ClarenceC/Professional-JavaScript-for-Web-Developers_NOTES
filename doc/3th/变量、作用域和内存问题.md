# 变量、作用域和内存问题

## 变量
JavaScript 变量是一个松散类型的的变量，没有数据类型规则的约束，这另到使用的时候既强大，又容易出问题。

JavaScript 变量分为两种类型的值：

1. 基本类型： Undefined, Null, Boolean, Number, String
2. 动态引用类型： Object，Array, Date, Reg, Function, Symbol

这样划分其实是根据内存的堆和栈划分的,基本类型会保存在栈中，而动态类型会保存在堆中。
他们两有什么区别呢：

基本类型是直接保存在栈上的，固定大小直接写入。而动态引用类型是数据保存在堆上，留了一个引用地址出来保存在栈上。使用的时候会先调用栈上的地址再去查找堆上面的数据。

在复制变量的时候，基本类型由于可快速知道内存大小，可以直接复制到值，而动态引用类型赋值复制只是复制了堆上面的内存地址，所以操作的时候还是操作回原来的对象。

在数据传参的时候也是一样的。基本类型会直接复制一份到函数的参数上面，而动态引用类型会传一份内存地址到函数参数上面在函数里面操作动态类型，会修改原来动态类型

```javascript
    // 基础类型
    var num = 5
    var add = function(num) {
        num += 1
        console.log(num)
    }
    add(num) // 6
    console.log(num) //5

    // 动态类型
    var obj = {
        a: 5
    }
    var add = function(obj) {
        obj.a += 1
        console.log(obj.a)
    }
    add(obj) // 6
    console.log(obj.a) //6
```

## 检查类型的方法
JavaScript 这么松散随意的变量，我们在类型判断方面就必须要严谨一些了。

1. `typeof`

ECMAScript 提供了一个检测类型的方法`typeof`,不过这个方法不怎好使只能检查基础类型,有限的类型判断，动态类型全部都显示为 "object"

```javascript
typeof "string" // "string"
typeof 5 // "number"
typeof false // "boolean"
typeof NaN // "number"
typeof undefined // "undefined"
typeof null // "object"
typeof {} // "object"
typeof [] // "object"
typeof (new RegExp()) // "object"
typeof (new Date()) // "object"
typeof function(){} // "function"
typeof Symbol('symbol') // "symbol"
```

2. `instanceof`

**语法**
`result = variable instanceof constructor`

由于 `typeof` 的局限性，（对于引用类型只能判断是不是 object 而无法具体判断是那种）. ECMAScript 引入了 `instanceof`, `instanceof` 是通过原型链来判断的,这里都不写具体 `instanceof` 方法判定原型链的具体实现了。`instanceof` 能轻松判断 object 是那种类型的，不`instanceof` 还是有不靠谱的地方比如下面：

```javascript
    var a = {}
    a instanceof Object // true 判断对象类型没有问题

    5 instanceof Number //false 判断不了基础类型
    var num = new Number(5) 
    num instanceof Number // true 基础类型需要新建成对象才能判断

    var fun = function(){}
    fun instanceof Array // true fun 是 Function 对象继承的没问题
    fun instanceof Object // true 
    // fun 也是 Object 对象这跟继承链最顶层 Object 和 Function 相互继承有关系，所以也是 true， 这就有问题了怎知道那时是真 Object 还是 Function 
```
